class:: NdMSpace
categories:: Live Coding
summary:: NdM environment

DESCRIPTION::

link::Classes/NdMSpace:: is a live-coding container that manages NdM objects as environment variables (strong::~key::),
similar in usage to link::Classes/ProxySpace::.
When a function or value is assigned to strong::~key = ...:: while an NdMSpace is active,
or when a function is wrapped with strong::nd { ... }:: and stored into a key,
it is automatically converted into an NdM instance, which can then be controlled uniformly through
methods such as strong::play::, strong::stop::, strong::free::, strong::out::, strong::fade::, and strong::tag::.

When strong::enter:: is called, the NdMSpace becomes the active environment,
and all strong::~key:: lookups resolve to this space.
Each key creates or updates an NdM node, and multiple NdMSpaces may be entered or exited,
allowing the user to switch environments cleanly.
Calling strong::exit:: restores the previous environment without destroying the stored NdM objects.

NdMSpace provides unified management of NdM registration, tag grouping, node state inspection,
argument-bus (argBus) allocation, and cleanup routines.
It also offers space-wide operations such as strong::stopAll::, strong::freeAll::, strong::reset::, and strong::clean::,
enabling safe handling of large sets of NdM nodes during live coding.

To ensure proper coordination with fade operations, strong::fadeGap:: specifies a minimum waiting time
between issuing fade-related commands and performing cleanup.
This prevents premature bus reuse or node removal while fade envelopes are still active on the server.

subsection::First Example

code::
a = NdMSpace.enter;
~car = nd { |mod| SinOsc.ar(mod * 200 + 400, 0, 0.2) }.out([0, 1]).play;
~mod0 = nd { SinOsc.ar(10) }.out(~car[\mod]).fade(5);
~mod1 = nd { LFNoise0.ar(1) }.out(~car[\mod]).fade(5);
~mod0.play;
~mod1.play;
~mod0.stop;
~mod1.stop;
~car.stop;
a.reset;
a.exit;
::

note::
For a full teardown of an NdMSpace, use strong::reset:: followed by strong::exit::.
Calling strong::clean:: only removes stale references and does not clear keys, argument buses, or tags.
Thus strong::clean:: -> strong::exit:: leaves NdM objects and environment bindings in place,
and does not constitute a complete shutdown of the space.
::

CLASSMETHODS::

subsection::Creation

method::enter
Create and activate a new NdMSpace.
The environment becomes the current top-level mapping for NdM keys (strong::~osc::, strong::~lfo:: etc.).
If another NdMSpace is already active, it is preserved and can be restored by calling its strong::exit:: method.
The returned object is the newly created NdMSpace instance.

method::exit
Leave the currently active NdMSpace.
All mappings, NdM nodes, and tag associations remain stored in the instance, but the global environment is restored to the state prior to strong::enter::.
This method does not free or stop nodes automatically; users may call strong::stopAll:: or strong::freeAll:: explicitly if required.

method::fromFunction
Create a temporary NdMSpace, evaluate a function within it, and return the resulting space.
Useful for building a space programmatically without affecting the current environment.

method::current
Return the NdMSpace instance that is currently active.
If no NdMSpace has been entered, this returns strong::nil::.

subsection::Lookup

method::get
Retrieve an NdM instance by key symbol.
Equivalent to accessing strong::~key:: while the NdMSpace is active.
Returns strong::nil:: if the key is unbound.

method::nodes
Return all NdM instances currently registered in the active NdMSpace.
This includes both playing and stopped nodes.

subsection::Class-side control

method::stopAll
Send a stop request to all NdM instances in the active NdMSpace.
Fade-out is applied according to each instance’s fade settings.

method::freeAll
Free all NdM instances in the active NdMSpace and clear associated server nodes.
Argument buses remain allocated unless explicitly cleared by strong::reset:: or strong::clean::.

method::reset
Clear all NdM mappings, argument buses, and tag associations from the active NdMSpace.
This prepares the space for a fresh set of definitions.

method::clean
Remove internal references to NdM objects that have been freed or are no longer active.
This does not modify active nodes.

method::status
Print a summary of the active NdMSpace:
registered keys, tag distribution, output buses, and basic lifecycle information.

method::dump
Post the full internal state of the active NdMSpace in a human-readable form.
This includes keys, associated NdM instances, argument buses, and monitor information.

method::dumpKey
Post detailed information for a single NdM key.
Useful for debugging function definitions, argument bus assignments, and tag membership.

subsection::Class-side tags

method::stopTag
Stop all NdM instances associated with the given tag symbol.
Fade-out is applied.

method::playTag
Play or re-activate all NdM instances under the given tag symbol.

method::freeTag
Free all NdM instances associated with the given tag symbol.
Removes server nodes immediately after fade-out.

method::tags
Return a list of all tag symbols currently registered in the active NdMSpace.

method::nodesForTag
Return all NdM instances associated with the given tag symbol.




INSTANCEMETHODS::

subsection::Space control

method::exit
Restore the environment that was active before this NdMSpace was entered.
The mappings and NdM nodes belonging to this space remain stored in the instance, and can be reactivated again by calling strong::enter::.
This does not automatically stop or free nodes.

method::stopAll
Send a stop request to all NdM instances registered in this NdMSpace.
Fade-out is applied according to each instance’s own fade settings.

method::freeAll
Free all NdM instances managed by this NdMSpace.
Server nodes are removed after their release envelopes complete.
Argument buses remain allocated until explicitly cleaned.

method::reset
Clear all key–NdM mappings, argument buses, and tag associations managed by this NdMSpace.
This prepares the space for rebuilding from scratch.

method::clean
Remove references to NdM instances that have been freed, stopped permanently, or are no longer valid.
Does not affect currently active nodes.

method::status
Post a short summary of this NdMSpace, including current keys, node states, and basic allocation details.

method::fadeGap
Get or set the class-level delay (in seconds) that NdMSpace waits after issuing fade-related operations such as strong::stopAll:: or strong::freeAll::.
This gap allows fade envelopes to finish on the server before node cleanup, bus reuse, or internal resets occur.

subsection::Debug flag (space-wide)

method::dbg
Get or set the current default debug flag for the active NdMSpace.

Calling strong::dbg(1):: or strong::dbg(0):: updates two things:

list::
## The space-level default debug value used when converting strong::nd { ... }:: into an NdM instance.
## The debug flag of all currently existing NdM instances in the space (applied immediately).
::

This is designed to prevent debug settings from being lost when a key is repeatedly redefined during live coding.

argument::value
An optional value to set the flag.

list::
## Number: strong::value > 0:: becomes 1, otherwise 0.
## Boolean: strong::true:: becomes 1, otherwise 0.
::

If omitted, returns the currently stored default value (nil/0/1).

note::
NdM also has an instance-side strong::dbg:: flag.
strong::NdMSpace.dbg:: controls the default and applies it to all existing nodes,
while strong::NdM.dbg:: affects only that single node.
::

subsection::Lookup

method::get
Retrieve an NdM instance in this NdMSpace by key symbol.
Equivalent to reading strong::~key:: while this space is active.
Returns strong::nil:: if the key is not present.

method::nodes
Return all NdM instances registered in this NdMSpace.
Includes playing, stopped, and dormant nodes.

subsection::Tag control

method::stopTag
Stop all NdM instances associated with the given tag symbol in this space.
Fade-out is applied.

method::playTag
Play or re-activate all NdM instances associated with the given tag symbol.

method::freeTag
Free all NdM instances associated with the given tag symbol.
Nodes are removed from the server after fade-out.

method::tags
Return all tag symbols currently tracked by this NdMSpace.

method::nodesForTag
Return all NdM instances associated with the given tag symbol.
Useful for monitoring, group control, or batch operations.

subsection::Monitoring

method::dump
Post the full internal state of this NdMSpace, including NdM keys, argument buses, tags, and monitor data.

method::dumpKey
Post detailed information about a specific NdM key within this NdMSpace.
Shows function details, argument buses, output mapping, and tag membership.

subsection::Internal

method::initForServer
Internal method.
Initialize this NdMSpace for a specific server instance.
Called automatically when entering the space or creating proxies; not intended for direct user invocation.

method::makeProxy
Internal method.
Create and register a proxy object (usually an NdM instance) for a given key.
Called when a new strong::~key:: is assigned.

method::put
Internal method.
Store an NdM instance or value under a given key symbol inside this NdMSpace.
Used by assignment and internal update routines.



section::Known issues and timing-related artifacts

In certain live-coding situations, you may notice brief amplitude or envelope fluctuations
("audio wobble") when redefining nodes rapidly.

This can occur when:

list::
## An NdM instance is redefined repeatedly in a short time span.
## Function switching (apply) overlaps with fade-in / fade-out processing.
## switchDur or fade times are very short.
::

This behavior is not a bug in the user API, but a known limitation related to
asynchronous apply scheduling and server-side envelope timing.

note::
NdM is designed to prioritize safety and consistency over strict sample-accurate continuity
during live redefinition.
In rare edge cases, overlapping apply requests may result in audible transitions.
::

Workarounds and recommendations:

list::
## Avoid extremely short switchDur values when redefining nodes rapidly.
## Insert a small delay between successive redefinitions if strict continuity is required.
## Treat apply-based function switching as a musical gesture rather than a sample-accurate operation.
::

This issue is documented for transparency.
No immediate fix is applied, but future versions may refine apply synchronization.



section::Returning Bus objects from nd functions

In NdMSpace, the expression strong::~node[arg]:: returns a Bus object that represents
the argument bus allocated for that node's argument.

This Bus is intended to be used as a routing destination (e.g. out bus for modulators),
not as a UGen signal value inside a SynthDef graph.

If an nd function returns a Bus object as its signal output, it may later trigger
SuperCollider errors such as "Message '*' not understood" when the system applies
gain envelopes or other arithmetic operations.

If you intend to read audio/control from a bus inside the UGen graph, explicitly use
In.ar(busIndex) or InFeedback.ar(busIndex) (and choose the correct rate and channel count).

note::
NdM does not guarantee type validation of arbitrary return values from user functions.
Returning a Bus is allowed by the language but is not meaningful as a signal.
::



section::Lazy-bus notation (pre-allocating argument buses)

In NdMSpace, accessing an argument bus using the syntax
code::
~node[argName]
::
returns the Bus associated with that argument.

When this access occurs before the corresponding NdM is defined,
NdMSpace automatically creates a silent placeholder NdM and
allocates the required argument bus on demand.
This behavior is available only inside an active NdMSpace.

This allows argument buses to be reserved *before* an
code::
nd { ... }
::
definition exists.
This usage pattern is referred to as the strong::lazy-bus notation::.

note::
The stability of the Bus in lazy-bus notation is guaranteed by NdM's
persistent argument-bus history.
Argument buses are not tied to the lifetime of a specific Synth or
NodeProxy instance, but are instead associated with a pair of
strong::(node key, argument name):: and recorded in NdMNameSpace.

When code::~node[argName]:: is evaluated, NdMNameSpace either recalls an
existing bus index for that key/argument pair or allocates a new one and
stores it immediately.
Later definitions or redefinitions of the same node key reuse the stored
bus information, ensuring that the routing destination remains stable
even if the NdM instance itself is recreated.

As a result, argument buses survive live redefinition, deferred node
creation, and function switching, allowing node graphs to be assembled
incrementally without breaking existing connections.
::

subsection::Motivation

Lazy-bus notation makes it possible to write node connections
from either direction:

list::
## Define modulators before carriers
## Reserve routing destinations before the actual sound function exists
## Keep argument buses stable across live redefinitions
::

This is especially useful in live coding and incremental patch construction.

subsection::Example: defining a modulator before its carrier

code::
a = NdMSpace.enter;

~mod = nd { SinOsc.ar(5).range(100, 400) }.out(~car[\frq]).play;

// The carrier (~car) is not defined yet.
// Accessing ~car[\frq] here allocates and returns the argument Bus lazily.
// A silent placeholder NdM for ~car is created at this point.

~car = nd { |frq| SinOsc.ar(frq, 0, 0.1) }.out([0, 1]).play;

// The carrier is defined after the modulator.
// The argument \frq automatically reuses the same Bus that was
// previously allocated by ~car[\frq].

~osc[\frq];       // Audio bus
~osc[\frq_k];     // Control bus
~osc_k[\frq];     // Control bus
~osc_k[\frq_a];   // Audio bus
~osc_a[\frq_k];   // Control bus
::

subsection::Behavior notes

list::
## code::~node[argName]:: returns a Bus object, not a UGen signal.
   It is intended for routing destinations (for example, as an out bus).
   If you want to read from a bus inside a SynthDef, use
   code::In.ar::, code::InFeedback.ar::, or code::In.kr:: explicitly.

## When the node key does not yet exist, NdMSpace creates
   a silent placeholder NdM associated with that key.
   When the node is later defined using
   code::~node = nd { ... }::,
   the same key and argument-bus history are reused.

## This automatic placeholder creation occurs only inside NdMSpace.
   Outside of NdMSpace, accessing an undefined environment variable
   behaves normally and does not allocate buses.
::

subsection::Recommended usage

Reserve argument buses only after entering NdMSpace
using code::NdMSpace.enter::.
Then define or redefine nodes freely.
This enables building node chains both from upstream
(modulators) and downstream (carriers) sides while keeping
bus routing stable.



EXAMPLES::

subsection::Preparing NdMSpace and a basic node

code::
// ** Enter NdMSpace mode and get a front-end handle **

a = NdMSpace.enter;

// ** Basic node setup **

~osc = nd { SinOsc.ar(440, 0, 0.2) };	// define audio function for this node
~osc.out([0,1]);	// route output to buses 0 and 1 (Array mapping rules apply; see NdM out specification)
~osc.fade(1);		// set fade time (seconds) for play/stop/free
~osc.tag(\osc);		// add tag \osc to this node
~osc.play;			// start playback with fade-in

// ** The same can be written with method chaining **

~osc = nd { SinOsc.ar(440, 0, 0.2) }.out([0,1]).fade(1).tag(\osc).play;

// ** The same can be written with short aliases **

~osc = nd { SinOsc.ar(440, 0, 0.2) }.o([0,1]).f(1).t(\osc).p;

// ** Start / stop /  free the node **

~osc.play;          // resume playback with fade-in
~osc.stop;          // stop with fade-out (keep node for later reuse)
~osc.free;          // free the underlying NodeProxy / Synth and release resources
::

note::
Aliases strong::o/f/t/p:: are available on the temporary builder returned by strong::nd { ... }::.
Aliases strong::s:: are available on NdM instances.
::

subsection::Inspecting and replacing a node

code::
// ** Inspect node properties **

~osc.key;           // get the NdM key (symbol name)
~osc.out;           // get current output bus specification
~osc.fade;          // get current fade time
~osc.tag;           // get current tag list for this node
~osc.func.postcs;   // print current function source code to the post window

// ** Replace the function (carrier waveform change) **

~osc = nd { LFTri.ar(100, 0, 0.2) };   // assign a new function; key and buses are kept

// ** Fade time when switching functions **

~osc.switchDur;         // get current function-switch fade time
~osc.switchDur = 0.05;  // set crossfade time (seconds) when replacing the function

// ** Space-wide debug default (recommended for live coding) **

a.dbg(1);  // enable debug for all existing NdM nodes and for future nd { ... } conversions

// ** Debug-related flags **

~osc.dbg = 1;       // enable debug logging for this node
~osc.poll = 1;      // enable polling for debug UGens inside this node
~osc.dbg = 0;       // disable debug logging
~osc.poll = 0;      // disable polling

a.dbg(0);  // disable debug for all existing nodes and for future conversions
::

subsection::Connecting NdMs via argument buses

note::
If an output Array contains Bus objects, all Bus elements must share the same rate.
Mixed audio/control bus rates inside a single out specification throw NdMError.
::

code::
// ** Connect nodes: carrier and modulators **

// See 'Lazy-bus notation'
~mod0 = nd { SinOsc.ar(10).range(0, 1) }.out(~car[\mod]).fade(2).tag(\fm);

// Add another modulation signal to same bus
~mod1 = nd { LFNoise0.ar(1) }.out(~car[\mod]).fade(2).tag(\fm);

// The carrier
~car = nd { |mod| SinOsc.ar(mod * 200 + 200, 0, 0.2) }.out([0,1]).fade(2).tag(\fm);


// ** Obtain argument buses **

~car.bus(\mod);  // explicitly get the Bus object for argument \mod
~car[\mod];      // shorthand access to the bus for argument \mod

~car.play;
~car.stop;
~mod0.play;
~mod0.stop;
~mod1.play;
~mod1.stop;

// ** Specifying signal rate of argument buses with _a/_k suffixes **

~osc = nd { | frq_a, amp_k | SinOsc.ar(frq_a, 0, amp_k) };	// frq_a -> ar, amp_k -> kr
~osc_k = nd { | frq, amp | SinOsc.ar(frq, 0, amp) };		// frq -> kr, amp -> kr
~osc_k = nd { | frq_a, amp | SinOsc.ar(frq_a, 0, amp) };	// frq_a -> ar, amp -> kr
a.dumpKey(\osc);	// dump internal NdM namespace / monitor status, by key
a.dumpKey(\osc_k);
::

subsection::Tag-based group control

code::
// ** Tag-based control from the NdMSpace handle **

a.stopTag(\fm);  // stop all NdM instances tagged with \fm
a.playTag(\fm);  // play all NdM instances tagged with \fm
a.freeTag(\fm);  // free all NdM instances tagged with \fm

// ** Tag inspection and edit **

~osc.tag;
~osc.untag(\osc);    // remove tag \osc from this node
a.tags;              // list all tags currently registered in NdMSpace
::

subsection::Namespace-level utilities

code::
// ** Global control from NdMSpace handle **

a.stopAll;       // stop all NdM instances (fade-out only)
a.freeAll;       // free all NdM instances
a.dump;          // dump internal NdM namespace / monitor status
a.reset;         // reset NdMNameSpace (clear key registry without playing anything)
a.clean;	        // free all NdM instances and then reset NdMNameSpace
a.status;        // print a compact list of active NdM instances
a.fadeGap;       // get global fade gap (delay before VarLag-based fade uses fade time)
a.exit;          // leave NdMSpace and restore the previous Environment

a.nodes.do { |ndm| ndm.key.postln };                 // print keys of all active NdM instances
a.nodesForTag(\fm).do { |ndm| ndm.key.postln };      // print keys of all NdM instances tagged with \fm

// ** Retrieve an NdM instance by key **

b = a.get(\osc);    // look up NdM instance whose key is \mod1
b.tag(\hoge);
b.tag;
::
