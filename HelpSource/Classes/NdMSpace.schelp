class:: NdMSpace
categories:: NdM, Live Coding
summary:: NdM environment

DESCRIPTION::

link::Classes/NdMSpace:: is a live-coding container that manages NdM objects as environment variables (strong::~key::),
similar in usage to link::Classes/ProxySpace::.
When a function or value is assigned to strong::~key = ...:: while an NdMSpace is active,
or when a function is wrapped with strong::nd { ... }:: and stored into a key,
it is automatically converted into an NdM instance, which can then be controlled uniformly through
methods such as strong::play::, strong::stop::, strong::free::, strong::out::, strong::fade::, and strong::tag::.

The strong::nd { ... }:: notation is only available inside an active NdMSpace
between strong::NdMSpace.enter:: and strong::NdMSpace.exit::.

When strong::enter:: is called, the NdMSpace becomes the active environment,
and all strong::~key:: lookups resolve to this space.
Each key creates or updates an NdM node, and multiple NdMSpaces may be entered or exited,
allowing the user to switch environments cleanly.

Entering a space also establishes a boundary for NdM lifecycle coordination,
including argument-bus allocation, graph tracking, monitoring, and restore handling.
Calling strong::exit:: restores the previous environment while keeping all NdM objects,
bus histories, and graph state stored in the space instance for later reactivation.

NdMSpace provides unified management of NdM registration, tag grouping, node state inspection,
argument-bus (argBus) allocation, and cleanup routines.
It also offers space-wide operations such as strong::stopAll::, strong::freeAll::, strong::reset::, and strong::clean::,
enabling safe handling of large sets of NdM nodes during live coding.

To ensure proper coordination with fade operations, strong::fadeGap:: specifies a minimum waiting time
between issuing fade-related commands and performing cleanup.
This prevents premature bus reuse or node removal while fade envelopes are still active on the server.

subsection::First Example

code::
a = NdMSpace.enter;
~car = nd { |mod| SinOsc.ar(mod * 200 + 400, 0, 0.2) }.out([0, 1]).play;
~mod0 = nd { SinOsc.ar(10) }.out(~car[\mod]).fade(5);
~mod1 = nd { LFNoise0.ar(1) }.out(~car[\mod]).fade(5);
~mod0.play;
~mod1.play;
~mod0.stop;
~mod1.stop;
~car.stop;
a.reset;
a.exit;
::

note::
strong::clean:: stops and frees all NdM instances in the current space
and resets internal state (keys, argument buses, tags, and graph bookkeeping),
preparing the environment for a fresh setup.

This example relies on clean performing a full reset.
Use strong::reset:: followed by strong::exit:: when you only want to leave
the current space and restore the previous environment without freeing nodes.
::

CLASSMETHODS::

subsection::Creation

method::enter
Create and activate a new NdMSpace.
The environment becomes the current top-level mapping for NdM keys (strong::~osc::, strong::~lfo:: etc.).
If another NdMSpace is already active, it is preserved and can be restored by calling its strong::exit:: method.
The returned object is the newly created NdMSpace instance.

method::exit
Leave the currently active NdMSpace.
All mappings, NdM nodes, and tag associations remain stored in the instance, but the global environment is restored to the state prior to strong::enter::.
This method does not free or stop nodes automatically; users may call strong::stopAll:: or strong::freeAll:: explicitly if required.

method::fromFunction
Create a temporary NdMSpace, evaluate a function within it, and return the resulting space.
Useful for building a space programmatically without affecting the current environment.

method::current
Return the NdMSpace instance that is currently active.
If no NdMSpace has been entered, this returns strong::nil::.

subsection::Lookup

method::get
Retrieve an NdM instance by key symbol.
Equivalent to accessing strong::~key:: while the NdMSpace is active.
Returns strong::nil:: if the key is unbound.

method::nodes
Return all NdM instances currently registered in the active NdMSpace.
This includes both playing and stopped nodes.

subsection::Class-side control

method::stopAll
Send a stop request to all NdM instances in the active NdMSpace.
Fade-out is applied according to each instance’s fade settings.

method::freeAll
Free all NdM instances in the active NdMSpace and clear associated server nodes.
Argument buses remain allocated unless explicitly cleared by strong::reset:: or strong::clean::.

method::reset
Clear all NdM mappings, argument buses, and tag associations from the active NdMSpace.
This prepares the space for a fresh set of definitions.

method::clean
Stop and free all NdM instances, then reset the active NdMSpace (keys, argument buses, tags, and graph state).
Convenience helper equivalent to strong::exitAll:: + strong::freeAll:: + strong::reset::.

method::status
Print a summary of the active NdMSpace:
registered keys, tag distribution, output buses, and basic lifecycle information.

method::dump
Post the full internal state of the active NdMSpace in a human-readable form.
This includes keys, associated NdM instances, argument buses, and monitor information.

method::dumpKey
Post detailed information for a single NdM key.
Useful for debugging function definitions, argument bus assignments, and tag membership.

subsection::Class-side tags

method::stopTag
Stop all NdM instances associated with the given tag symbol.
Fade-out is applied.

method::playTag
Play or re-activate all NdM instances under the given tag symbol.

method::freeTag
Free all NdM instances associated with the given tag symbol.
Removes server nodes immediately after fade-out.

method::tags
Return a list of all tag symbols currently registered in the active NdMSpace.

method::nodesForTag
Return all NdM instances associated with the given tag symbol.




INSTANCEMETHODS::

subsection::Space control

method::exit
Restore the environment that was active before this NdMSpace was entered.
The mappings and NdM nodes belonging to this space remain stored in the instance, and can be reactivated again by calling strong::enter::.
This does not automatically stop or free nodes.

method::stopAll
Send a stop request to all NdM instances registered in this NdMSpace.
Fade-out is applied according to each instance’s own fade settings.

method::freeAll
Free all NdM instances managed by this NdMSpace.
Server nodes are removed after their release envelopes complete.
Argument buses remain allocated until explicitly cleaned.

method::reset
Clear all key–NdM mappings, argument buses, and tag associations managed by this NdMSpace.
This prepares the space for rebuilding from scratch.

method::clean
Stop and free all NdM instances, then reset the active NdMSpace (keys, argument buses, tags, and graph state).
Convenience helper equivalent to strong::exitAll:: + strong::freeAll:: + strong::reset::.

method::status
Post a short summary of this NdMSpace, including current keys, node states, and basic allocation details.

method::fadeGap
Get or set the class-level delay (in seconds) that NdMSpace waits after issuing fade-related operations such as strong::stopAll:: or strong::freeAll::.
This gap allows fade envelopes to finish on the server before node cleanup, bus reuse, or internal resets occur.

subsection::Default output bus (defaultOut)

method::defaultOut
Get or set the default output-bus specification for this NdMSpace.

If called without arguments, returns the current default output-bus specification.

If called with an argument, sets the default output bus used when a new NdM
is created in this space and no explicit output bus is specified.

If the key already has an NdM, the output bus is inherited from the existing NdM,
regardless of defaultOut.

argument::outBus
The default output bus used for new NdM nodes when no explicit output is specified.

list::
## nil: clear the default (fall back to bus 0).
## Integer: audio-rate output starting bus index.
## Bus: output starting bus index is strong::bus.index::, and the output rate follows strong::bus.rate::.
## Array: a list of output targets. Each element must be an Integer or a Bus.
::

If an invalid type is provided, the value is ignored and an error is reported.

subsection::Debug flag (space-wide)

method::dbg
Get or set the current default debug flag for the active NdMSpace.

Calling strong::dbg(1):: or strong::dbg(0):: updates two things:

list::
## The space-level default debug value used when converting strong::nd { ... }:: into an NdM instance.
## The debug flag of all currently existing NdM instances in the space (applied immediately).
::

This is designed to prevent debug settings from being lost when a key is repeatedly redefined during live coding.

argument::value
An optional value to set the flag.

list::
## Number: strong::value > 0:: becomes 1, otherwise 0.
## Boolean: strong::true:: becomes 1, otherwise 0.
::

If omitted, returns the currently stored default value (nil/0/1).

note::
NdM also has an instance-side strong::dbg:: flag.
strong::NdMSpace.dbg:: controls the default and applies it to all existing nodes,
while strong::NdM.dbg:: affects only that single node.
::

subsection::Lookup

method::get
Retrieve an NdM instance in this NdMSpace by key symbol.
Equivalent to reading strong::~key:: while this space is active.
Returns strong::nil:: if the key is not present.

method::nodes
Return all NdM instances registered in this NdMSpace.
Includes playing, stopped, and dormant nodes.

subsection::Tag control

method::stopTag
Stop all NdM instances associated with the given tag symbol in this space.
Fade-out is applied.

method::playTag
Play or re-activate all NdM instances associated with the given tag symbol.

method::freeTag
Free all NdM instances associated with the given tag symbol.
Nodes are removed from the server after fade-out.

method::tags
Return all tag symbols currently tracked by this NdMSpace.

method::nodesForTag
Return all NdM instances associated with the given tag symbol.
Useful for monitoring, group control, or batch operations.

subsection::Monitoring

method::dump
Post the full internal state of this NdMSpace, including NdM keys, argument buses, tags, and monitor data.

This method is the primary diagnostic entry point for observing
dirty state, graph activity, and rebuild-related conditions.

method::dumpKey
Post detailed information about a specific NdM key within this NdMSpace.
Shows function details, argument buses, output mapping, and tag membership.

This method is commonly used to inspect graph participation,
dependency resolution, and rebuild-related state for a single node.

subsection::Graph rebuilding (dirty / rebuild)

NdMSpace maintains a dependency graph between NdM nodes based on argument-bus connections.
When this graph changes, the space enters a strong::dirty:: state, meaning that execution order
is no longer guaranteed to be correct.

While the space is dirty:

list::
## Execution order may be temporarily outdated until graph rebuilding completes.
## Graph rebuilding is attempted only when the dirty flag is set.
## A successful rebuild establishes a correct execution order
   between argument-bus writers and readers.
## The dirty flag is cleared only after a successful rebuild completes.
## If a safe execution order cannot be determined, the rebuild is aborted
   and no changes are applied.
::

This mechanism ensures that NdM nodes are reordered only when necessary,
and that unsafe or ambiguous graph states are never applied silently.

method::requestGraphRebuild
Request a graph rebuild for the active NdMSpace.

Multiple rebuild requests issued in a short time span are automatically
coalesced into a single rebuild attempt.
If a rebuild is already running, an additional request schedules a rerun
after the current rebuild finishes, ensuring that graph updates are applied
in a stable and serialized manner.

method::rebuildGraphIfDirty
Attempt to rebuild the execution order of NdM nodes if the space is marked dirty.

If the space is not dirty, this method does nothing.
If the space is dirty, NdMSpace computes a safe execution order based on
argument-bus dependencies and applies it to server node groups.

If no valid order can be determined (for example, due to a feedback loop),
the rebuild is aborted and the space remains dirty.

note::
Graph restoration after reset or stop/play cycles is implemented outside NdMSpace.
See strong::NdMNameSpace.restoreFromNode:: for namespace-level restoration,
and strong::NdM.restoreGraphFromOutbus:: for NdM-side helper logic applied
immediately before playback.
::

subsection::Internal

method::initForServer
Internal method.
Initialize this NdMSpace for a specific server instance.
Called automatically when entering the space or creating proxies; not intended for direct user invocation.

method::makeProxy
Internal method.
Create and register a proxy object (usually an NdM instance) for a given key.
Called when a new strong::~key:: is assigned.

method::put
Internal method.
Store an NdM instance or value under a given key symbol inside this NdMSpace.
Used by assignment and internal update routines.



section::Known issues and timing-related artifacts

In certain live-coding situations, you may notice brief amplitude or envelope fluctuations
("audio wobble") when redefining nodes rapidly.

This can occur when:

list::
## An NdM instance is redefined repeatedly in a short time span.
## Function switching (apply) overlaps with fade-in / fade-out processing.
## switchDur or fade times are very short.
::

This behavior is not a bug in the user API, but a known limitation related to
asynchronous apply scheduling and server-side envelope timing.

note::
NdM is designed to prioritize safety and consistency over strict sample-accurate continuity
during live redefinition.
In rare edge cases, overlapping apply requests may result in audible transitions.
::

Workarounds and recommendations:

list::
## Avoid extremely short switchDur values when redefining nodes rapidly.
## Insert a small delay between successive redefinitions if strict continuity is required.
## Treat apply-based function switching as a musical gesture rather than a sample-accurate operation.
::

This issue is documented for transparency.
No immediate fix is applied, but future versions may refine apply synchronization.



section::Returning Bus objects from nd functions

In NdMSpace, the expression strong::~node[arg]:: returns a Bus object that represents
the argument bus allocated for that node's argument.

This Bus is intended to be used as a routing destination (e.g. out bus for modulators),
not as a UGen signal value inside a SynthDef graph.

If an nd function returns a Bus object as its signal output, it may later trigger
SuperCollider errors such as "Message '*' not understood" when the system applies
gain envelopes or other arithmetic operations.

If you intend to read audio/control from a bus inside the UGen graph, explicitly use
In.ar(busIndex) or InFeedback.ar(busIndex) (and choose the correct rate and channel count).

note::
NdM does not guarantee type validation of arbitrary return values from user functions.
Returning a Bus is allowed by the language but is not meaningful as a signal.
::

subsection::Feedback loop restriction (bus assignment)

NdMSpace does not allow feedback loops in its bus-assignment graph.

If a feedback loop is detected between NdM nodes during graph rebuilding,
the rebuild process is aborted and bus assignment is not applied.

A feedback loop means that two or more NdM nodes depend on each other
via argument buses, for example:
code::
mod -> nod
nod -> mod
::
In such cases, NdMSpace cannot determine a safe rebuild order,
and stable bus assignment is no longer guaranteed.

When a feedback loop is detected, NdMSpace emits a warning:
code::
[WARN] NdM feedback loop detected (bus assignment is not allowed)
::
and keeps the graph in a dirty state without applying changes.

This restriction applies only to NdM's bus-assignment mechanism.
If audio-rate feedback is intentionally required,
use standard SuperCollider techniques such as InFeedback.ar
inside the SynthDef instead of NdM argument buses.

See strong::Graph rebuilding (dirty / rebuild):: for details on
how feedback loops cause rebuild attempts to abort and remain unsatisfied.

note::
If feedback processing is intentionally required, it must be implemented
explicitly inside the SynthDef using SuperCollider UGens such as
code::InFeedback.ar:: or code::LocalIn / LocalOut::.

NdM argument buses are designed for acyclic control and modulation routing only.
::


section::Early bus reference (pre-allocating argument buses)

In NdMSpace, accessing an argument bus using the syntax
code::
~node[argName]
::
returns the Bus associated with that argument.

When this access occurs before the corresponding NdM is defined,
NdMSpace automatically creates a silent placeholder NdM and
allocates the required argument bus on demand.
This behavior is available only inside an active NdMSpace.

This allows argument buses to be reserved *before* an
code::
nd { ... }
::
definition exists.
This usage pattern is referred to as the strong::early bus reference::.

note::
The stability of the Bus in early bus reference is guaranteed by NdM's
persistent argument-bus history.
Argument buses are not tied to the lifetime of a specific Synth or
NodeProxy instance, but are instead associated with a pair of
strong::(node key, argument name):: and recorded in link::Classes/NdMNameSpace::.

When code::~node[argName]:: is evaluated, NdMNameSpace either recalls an
existing bus index for that key/argument pair or allocates a new one and
stores it immediately.
Later definitions or redefinitions of the same node key reuse the stored
bus information, ensuring that the routing destination remains stable
even if the NdM instance itself is recreated.

As a result, argument buses survive live redefinition, deferred node
creation, and function switching, allowing node graphs to be assembled
incrementally without breaking existing connections.
::

subsection::Motivation

Early bus reference makes it possible to write node connections
from either direction:

list::
## Define modulators before carriers
## Reserve routing destinations before the actual sound function exists
## Keep argument buses stable across live redefinitions
::

This is especially useful in live coding and incremental patch construction.

subsection::Example: defining a modulator before its carrier

code::
a = NdMSpace.enter;

~mod = nd { SinOsc.ar(5).range(100, 400) }.out(~car[\frq]).play;

// The carrier (~car) is not defined yet.
// Accessing ~car[\frq] here allocates and returns the argument Bus early.
// A silent placeholder NdM for ~car is created at this point.

~car = nd { |frq| SinOsc.ar(frq, 0, 0.1) }.out([0, 1]).play;

// The carrier is defined after the modulator.
// The argument \frq automatically reuses the same Bus that was
// previously allocated by ~car[\frq].

~osc[\frq];       // Audio bus
~osc[\frq_k];     // Control bus
~osc_k[\frq];     // Control bus
~osc_k[\frq_a];   // Audio bus
~osc_a[\frq_k];   // Control bus
::

subsection::Behavior notes

list::
## code::~node[argName]:: returns a Bus object, not a UGen signal.
   It is intended for routing destinations (for example, as an out bus).
   If you want to read from a bus inside a SynthDef, use
   code::In.ar::, code::InFeedback.ar::, or code::In.kr:: explicitly.

## When the node key does not yet exist, NdMSpace creates
   a silent placeholder NdM associated with that key.
   When the node is later defined using
   code::~node = nd { ... }::,
   the same key and argument-bus history are reused.

## This automatic placeholder creation occurs only inside NdMSpace.
   Outside of NdMSpace, accessing an undefined environment variable
   behaves normally and does not allocate buses.
::

subsection::Recommended usage

Reserve argument buses only after entering NdMSpace
using code::NdMSpace.enter::.
Then define or redefine nodes freely.
This enables building node chains both from upstream
(modulators) and downstream (carriers) sides while keeping
bus routing stable.



EXAMPLES::

subsection::Preparing NdMSpace and a basic node

code::
// ** Enter NdMSpace mode and get a front-end handle **

a = NdMSpace.enter;
a.defaultOut = [0, 1];   // set default output buses for nodes without an explicit out

// ** Basic node setup **

~osc = nd { SinOsc.ar(440, 0, 0.2) };   // define audio function for this node
// output is routed to buses 0 and 1 via defaultOut
// (Array mapping rules apply; see NdM out specification)
~osc.fade(1);            // set fade time (seconds) for play/stop/free
~osc.tag(\osc);          // add tag \osc to this node
~osc.play;               // start playback with fade-in

// ** The same can be written with method chaining **

~osc = nd { SinOsc.ar(440, 0, 0.2) }.out([0,1]).fade(1).tag(\osc).play;

// ** The same can be written with short aliases **

~osc = nd { SinOsc.ar(440, 0, 0.2) }.o([0,1]).f(1).t(\osc).p;

// ** Start / stop /  free the node **

~osc.play;          // resume playback with fade-in
~osc.stop;          // stop with fade-out (keep node for later reuse)
~osc.free;          // free the underlying NodeProxy / Synth and release resources
::

note::
Aliases strong::o/f/t/p:: are available on the temporary builder returned by strong::nd { ... }::.
Aliases strong::s:: are available on NdM instances.
::

subsection::Inspecting and replacing a node

code::
// ** Inspect node properties **

~osc.key;           // get the NdM key (symbol name)
~osc.out;           // get current output bus specification
~osc.fade;          // get current fade time
~osc.tag;           // get current tag list for this node
~osc.func.postcs;   // print current function source code to the post window

// ** Replace the function (carrier waveform change) **

~osc = nd { LFTri.ar(100, 0, 0.2) };   // assign a new function; key and buses are kept

// ** Fade time when switching functions **

~osc.switchDur;         // get current function-switch fade time
~osc.switchDur = 0.05;  // set crossfade time (seconds) when replacing the function

// ** Space-wide debug default (recommended for live coding) **

a.dbg(1);  // enable debug for all existing NdM nodes and for future nd { ... } conversions

// ** Debug-related flags **

~osc.dbg = 1;       // enable debug logging for this node
~osc.poll = 1;      // enable polling for debug UGens inside this node
~osc.dbg = 0;       // disable debug logging
~osc.poll = 0;      // disable polling

a.dbg(0);  // disable debug for all existing nodes and for future conversions
::

subsection::Connecting NdMs via argument buses

note::
If an output Array contains Bus objects, all Bus elements must share the same rate.
Mixed audio/control bus rates inside a single out specification throw NdMError.
Errors related to invalid bus specifications are reported via link::Classes/NdMError::.
::

code::
// ** Connect nodes: carrier and modulators **

// See 'Early bus reference'
~mod0 = nd { SinOsc.ar(10).range(0, 1) }.out(~car[\mod]).fade(2).tag(\fm);

// Add another modulation signal to same bus
~mod1 = nd { LFNoise0.ar(1) }.out(~car[\mod]).fade(2).tag(\fm);

// The carrier
~car = nd { |mod| SinOsc.ar(mod * 200 + 200, 0, 0.2) }.fade(2).tag(\fm);


// ** Obtain argument buses **

~car.bus(\mod);  // explicitly get the Bus object for argument \mod
~car[\mod];      // shorthand access to the bus for argument \mod

~car.play;
~car.stop;
~mod0.play;
~mod0.stop;
~mod1.play;
~mod1.stop;

// ** Specifying signal rate of argument buses with _a/_k suffixes **

~osc = nd { | frq_a, amp_k | SinOsc.ar(frq_a, 0, amp_k) };	// frq_a -> ar, amp_k -> kr
~osc_k = nd { | frq, amp | SinOsc.ar(frq, 0, amp) };		// frq -> kr, amp -> kr
~osc_k = nd { | frq_a, amp | SinOsc.ar(frq_a, 0, amp) };	// frq_a -> ar, amp -> kr
a.dumpKey(\osc);	// dump internal NdM namespace / monitor status, by key
a.dumpKey(\osc_k);
::

subsection::Tag-based group control

code::
// ** Tag-based control from the NdMSpace handle **

a.stopTag(\fm);  // stop all NdM instances tagged with \fm
a.playTag(\fm);  // play all NdM instances tagged with \fm
a.freeTag(\fm);  // free all NdM instances tagged with \fm

// ** Tag inspection and edit **

~osc.tag;
~osc.untag(\osc);    // remove tag \osc from this node
a.tags;              // list all tags currently registered in NdMSpace
::

subsection::Namespace-level utilities

code::
// ** Global control from NdMSpace handle **

a.stopAll;       // stop all NdM instances (fade-out only)
a.freeAll;       // free all NdM instances
a.dump;          // dump internal NdM namespace / monitor status
a.reset;         // reset NdMNameSpace (clear key registry without playing anything)
a.clean;	        // free all NdM instances and then reset NdMNameSpace
a.status;        // print a compact list of active NdM instances
a.fadeGap;       // get global fade gap (delay before VarLag-based fade uses fade time)
a.exit;          // leave NdMSpace and restore the previous Environment

a.nodes.do { |ndm| ndm.key.postln };                 // print keys of all active NdM instances
a.nodesForTag(\fm).do { |ndm| ndm.key.postln };      // print keys of all NdM instances tagged with \fm

// ** Retrieve an NdM instance by key **

b = a.get(\osc);    // look up NdM instance whose key is \mod1
b.tag(\hoge);
b.tag;
::
