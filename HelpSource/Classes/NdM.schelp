class:: NdM
categories:: Live Coding
summary:: Ndef-based modular node wrapper with stable argument buses, fade/switch control, and NdMSpace integration

DESCRIPTION::

link::Classes/NdM:: is a stateful wrapper around link::Classes/Ndef:: used by link::Classes/NdMSpace::.
It provides **stable argument buses**, **per-node fade control**, and **function switching**
so that a running sound can be redefined safely during live coding.

When an NdM is created, it allocates (or reuses) a one-channel bus for each argument of the UGen
function, and the mapping strong::(key, argName) → (busIndex, rate):: is stored in the global
history manager link::Classes/NdMNameSpace::.
Because this mapping persists across redefinitions, modulators connected to these buses continue to work
even if the NdM function is replaced, and even if the NdM instance is freed and recreated later.

NdM also inserts internal control arguments strong::ndmAmp:: and strong::ndmFade:: for smooth
fade-in, fade-out, and function switching without clicks. These are implemented using VarLag and
a gated envelope inside the proxy function.

NdM is normally not instantiated directly; instead it is created via strong::nd-notation:: inside an
active NdMSpace, for example:

code::
~osc = nd { SinOsc.ar(440, 0, 0.1) }.out(0).play;
::

CLASSMETHODS::

private::initClass

subsection::Creation

method::new
Create (or reuse) an NdM node for the given symbolic strong::key::.
If an NdM with the same key already exists, its UGen function is replaced
and its argument buses are reused; otherwise a new internal link::Classes/Ndef::
and argument buses are allocated.
In all cases, the mapping is stored or updated in link::Classes/NdMNameSpace::.

argument::key
The symbolic identifier of the NdM.
Suffixes strong::_a:: and strong::_k:: specify default argument rate (audio or control).

argument::func
A UGen function strong::{ |arg1, arg2, ...| ... }::.
Each argument reads from its bus using strong::InFeedback.ar:: or strong::In.kr:: based on rate.
The function’s return signal must match the rate of the output bus.

argument::outbus
Optional output bus specification.
This can be one of:

list::
## Integer: audio-rate output starting bus index.
## Bus: output starting bus index is strong::bus.index::, and the output rate follows strong::bus.rate::.
## Array: a list of output targets. Each element must be an Integer or a Bus.
::

If strong::nil::, a default audio-rate bus 0 is used.

When an Array is given, NdM normalizes it to a list of bus indices.
Array elements may be Integers or Buses; Array[Bus] is supported.

note::
If an Array contains Bus objects, all Bus elements must share the same rate
(audio or control). Mixed bus rates inside one Array are not supported and throw NdMError.
::

INSTANCEMETHODS::

method::play
Start the NdM by building a proxy function that:

list::
## Reads all argument buses
## Evaluates strong::func::
## Applies fade processing via strong::ndmAmp:: and strong::ndmFade::
## Applies function-switch gating when necessary
## Writes the result to strong::outbus::
::

Then strong::proxy.play:: is called.
If fade time is set (via strong::fade::), audio enters smoothly.

method::stop
Fade out and stop audio playback.
The NdM instance, its buses, and its history in link::Classes/NdMNameSpace::
remain intact so you can call play again.

method::free
Fade out, clear the proxy, free argument buses, and unregister the NdM from the live-node table.
The bus history strong::(argName → busIndex, rate):: remains stored in NdMNameSpace
so that future NdM nodes with the same key reuse the same buses.

method::fade
Get or set the fade time in seconds used by play/stop/free and function switching.

subsection::Output routing (out / out_)

NdM writes the return signal of strong::func:: to strong::outbus:: using Out.ar or Out.kr.
The output behavior depends on the shape of the output specification and the signal.

note::
NdM argument buses are implemented as control buses and are read inside the running node
using strong::In.kr::.
On the SuperCollider server, control-bus writes (strong::Out.kr::) and reads
(strong::In.kr::) occur in node execution order within each control block.

When multiple nodes write to the same control bus, the value observed by a given node
depends on whether those writers have already executed in the current block.
As a result, a node cannot reliably read the final summed value of a shared control bus
independent of node execution order.

If deterministic results are required, ensure that writer nodes execute before reader
nodes by controlling server node order, or use an audio-rate signal path instead of
a control bus.
::

subsection::Allowed out specifications

strong::out(x):: accepts:

list::
## Integer
## Bus
## Array of (Integer or Bus)
::

Empty arrays are invalid.

subsection::Array mapping rules (no leakage)

When the normalized bus index is an Array, NdM applies these rules to avoid multichannel expansion leakage:

list::
## If the signal is an Array and strong::signal.size == busIndex.size::,
each channel is mapped explicitly:
strong::Out.(busIndex[i], signal[i])::.
## If the signal is mono (not an Array), NdM writes the same mono signal to each bus index
by calling Out once per element (mono map). NdM does not duplicate the signal and send it as a multichannel array.
::

note::
The mono-map rule prevents unintended writing to adjacent buses (e.g., bus 2 leakage when routing mono to [0, 1]).
::

method::bus
Return the link::Classes/Bus:: assigned to strong::argName::.
This is used to connect modulators (e.g., nd LFOs writing into parameter buses).

method::b
Return only the bus index for strong::argName:: (equivalent to strong::bus(argName).index::).

subsection::Rate Control

NdM supports rate inference through argument suffixes and name suffixes:

list::
## Argument suffix _a / _k overrides everything.
## Name suffix _a / _k sets default rate for arguments without suffix.
## Default rate (no suffix) is audio.
::

Example:

code::
NdM(\osc_k, { |freq_a, pan|
    ...
});
::

list::
## strong::freq_a:: → audio-rate (argument suffix)
## strong::pan:: → control-rate (name suffix \osc_k)
::

subsection::Fade / Switch Behaviour

NdM uses two internal control parameters:

list::
## strong::ndmAmp:: — smoothed with VarLag for play/stop/free fades
## strong::ndmGate:: — envelope for function switching
::

When the function is changed (via nd-notation or NdMSpace assignment),

list::
## old function fades out
## new function fades in
::

without clicks, using a short-lived gated envelope.

subsection::Rate mismatch detection

If the returned signal rate disagrees with the output-bus rate,
strong::NdMError:: is thrown with a message like:

list::
## NdM: rate mismatch (sig=ar, bus=kr)
::

subsection::Monitoring with NdMNameSpace

link::Classes/NdMNameSpace:: stores:

list::
## existing NdM instances per key
## the mapping strong::argName → (busIndex, rate)::
## tag associations used by NdMTag and NdMSpace
::

You may inspect the state using:

code::
NdMNameSpace.dumpStatus;
::

This includes both live nodes and preserved argument histories.

EXAMPLES::

subsection::Using NdM directly (without NdMSpace)

code::
// Create an NdM node with outbus 0
NdM(\ndm, { SinOsc.ar(440, 0, 0.1) }, 0);

// Use fade for a smooth start
NdM(\ndm).fade = 1.0;
NdM(\ndm).play;

// Inspect bus mapping and node state
NdMNameSpace.dumpStatus;

// Later, you can fade out and free:
NdM(\ndm).stop;
NdM(\ndm).free;
::

subsection::Basic usage inside NdMSpace

code::
a = NdMSpace.enter;

// Creates an NdM node but does not play yet.
// The argument bus for 'mod' is allocated and registered.
~car = nd { |mod| DC.ar(mod) };

NdMNameSpace.dumpStatus;
::

subsection::Connecting modulators

code::
~car = nd { |mod| SinOsc.ar(mod * 100 + 200, 0, 0.1) }.out([0, 1]).play;

// out accepts Bus directly:
~mod = nd { SinOsc.ar(5) }.out(~car[\mod]).play;

// Array[Bus] is also supported (normalized to bus indices):
~mod = nd { SinOsc.ar(6) }.out([~car[\mod]]).play;

NdMNameSpace.dumpStatus;

a.freeAll;
::

Here, the bus for strong::mod:: remains stable even if ~car is redefined.

subsection::Rate suffixes

code::
~suf = nd { |frq_a, pan_k| SinOsc.ar(frq_a).dup * pan_k };

NdMNameSpace.dumpKey(\suf);

a.reset;
a.exit;
::

This creates an audio-rate and control-rate bus respectively, visible in NdMNameSpace.

